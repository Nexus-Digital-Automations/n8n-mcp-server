fa033275086f1dcd3fbf9d77a4af88ba
// Mock for Zod to fix Jest ES module import issues
const createMockSchema = (type = 'any', constraints = {}) => {
  const validate = (data) => {
    // Handle undefined/null values
    if (data === undefined || data === null) {
      if (constraints.required !== false) {
        throw new Error(`Expected ${type}, received ${data === undefined ? 'undefined' : 'null'}`);
      }
      return data; // Allow undefined/null for optional fields
    }
    
    switch (type) {
      case 'string':
        if (typeof data !== 'string') throw new Error(`Expected string, received ${typeof data}`);
        if (constraints.min && data.length < constraints.min) throw new Error(`String must be at least ${constraints.min} characters`);
        if (constraints.max && data.length > constraints.max) throw new Error(`String must be at most ${constraints.max} characters`);
        if (constraints.email && !data.includes('@')) throw new Error('Invalid email format');
        if (constraints.url && !data.startsWith('http')) throw new Error('Invalid URL format');
        break;
      case 'number':
        if (typeof data !== 'number') throw new Error(`Expected number, received ${typeof data}`);
        if (constraints.min && data < constraints.min) throw new Error(`Number must be at least ${constraints.min}`);
        if (constraints.max && data > constraints.max) throw new Error(`Number must be at most ${constraints.max}`);
        break;
      case 'boolean':
        if (typeof data !== 'boolean') throw new Error(`Expected boolean, received ${typeof data}`);
        break;
      case 'object':
        if (typeof data !== 'object' || data === null) throw new Error(`Expected object, received ${typeof data}`);
        break;
      case 'array':
        if (!Array.isArray(data)) throw new Error(`Expected array, received ${typeof data}`);
        if (constraints.min && data.length < constraints.min) throw new Error(`Array must have at least ${constraints.min} items`);
        if (constraints.max && data.length > constraints.max) throw new Error(`Array must have at most ${constraints.max} items`);
        break;
    }
    return data;
  };

  return {
    parse: validate,
    safeParse: (data) => {
      try {
        return { success: true, data: validate(data) };
      } catch (error) {
        return { success: false, error: { message: error.message } };
      }
    },
    optional: () => createMockSchema(type, { ...constraints, required: false }),
    min: (value) => createMockSchema(type, { ...constraints, min: value }),
    max: (value) => createMockSchema(type, { ...constraints, max: value }),
    email: () => createMockSchema(type, { ...constraints, email: true }),
    url: () => createMockSchema(type, { ...constraints, url: true }),
    default: () => createMockSchema(type, constraints),
    refine: (refineFn, options) => {
      const originalValidate = validate;
      return {
        ...createMockSchema(type, constraints),
        parse: (data) => {
          const result = originalValidate(data);
          if (!refineFn(result)) {
            throw new Error(options?.message || 'Refinement failed');
          }
          return result;
        }
      };
    },
    transform: () => createMockSchema(type, constraints),
    pipe: () => createMockSchema(type, constraints),
    nullable: () => createMockSchema(type, constraints),
    nullish: () => createMockSchema(type, constraints),
    and: () => createMockSchema(type, constraints),
    or: () => createMockSchema(type, constraints),
    catch: () => createMockSchema(type, constraints),
    preprocess: () => createMockSchema(type, constraints),
    brand: () => createMockSchema(type, constraints),
  };
};

const mockZod = {
  z: {
    string: () => createMockSchema('string', { required: true }),
    number: () => createMockSchema('number', { required: true }),
    boolean: () => createMockSchema('boolean', { required: true }),
    any: () => createMockSchema('any'),
    unknown: () => createMockSchema('any'),
    void: () => createMockSchema('any'),
    null: () => createMockSchema('any'),
    undefined: () => createMockSchema('any'),
    literal: () => createMockSchema('any'),
    object: (shape) => ({
      shape,
      parse: (data) => {
        if (typeof data !== 'object' || data === null) {
          throw new Error(`Expected object, received ${typeof data}`);
        }
        // Validate each field in the shape if provided
        if (shape) {
          for (const [key, schema] of Object.entries(shape || {})) {
            const value = data[key];
            
            // Check if the field is present
            if (value !== undefined) {
              // Validate the field value using its schema
              if (schema?.parse) {
                schema.parse(value);
              }
            } else {
              // Check if field is required by testing if the schema throws for undefined
              if (schema?.parse) {
                try {
                  schema.parse(undefined);
                } catch (error) {
                  // Only throw if it's not an "optional" type error
                  if (!error.message.includes('received undefined')) {
                    throw new Error(`Missing required field: ${key}`);
                  }
                }
              }
            }
          }
        }
        return data;
      },
      safeParse: (data) => {
        try {
          return { success: true, data: mockZod.z.object(shape).parse(data) };
        } catch (error) {
          return { success: false, error: { message: error.message } };
        }
      },
      optional: () => createMockSchema('object'),
      refine: (refineFn, options) => ({
        ...mockZod.z.object(shape),
        parse: (data) => {
          const result = mockZod.z.object(shape).parse(data);
          if (!refineFn(result)) {
            throw new Error(options?.message || 'Refinement failed');
          }
          return result;
        }
      }),
      extend: () => createMockSchema('object'),
      merge: () => createMockSchema('object'),
      pick: () => createMockSchema('object'),
      omit: () => createMockSchema('object'),
      partial: () => createMockSchema('object'),
      deepPartial: () => createMockSchema('object'),
      required: () => createMockSchema('object'),
      passthrough: () => createMockSchema('object'),
      strict: () => createMockSchema('object'),
      strip: () => createMockSchema('object'),
      catchall: () => createMockSchema('object'),
    }),
    array: (item) => createMockSchema('array'),
    record: (value) => createMockSchema('object'),
    enum: (values) => ({
      values,
      parse: (data) => {
        if (!values.includes(data)) {
          throw new Error(`Expected one of [${values.join(', ')}], received ${data}`);
        }
        return data;
      },
      safeParse: (data) => {
        try {
          return { success: true, data: mockZod.z.enum(values).parse(data) };
        } catch (error) {
          return { success: false, error: { message: error.message } };
        }
      },
      optional: () => createMockSchema('any'),
    }),
    union: () => createMockSchema('any'),
    intersection: () => createMockSchema('any'),
    tuple: () => createMockSchema('array'),
    lazy: () => createMockSchema('any'),
    nativeEnum: () => createMockSchema('any'),
    function: () => createMockSchema('any'),
    instanceof: () => createMockSchema('any'),
    promise: () => createMockSchema('any'),
    date: () => createMockSchema('any'),
    bigint: () => createMockSchema('any'),
    symbol: () => createMockSchema('any'),
    map: () => createMockSchema('any'),
    set: () => createMockSchema('any'),
    nan: () => createMockSchema('any'),
    never: () => createMockSchema('any'),
    discriminatedUnion: () => createMockSchema('any'),
    coerce: {
      string: () => createMockSchema('string'),
      number: () => createMockSchema('number'),
      boolean: () => createMockSchema('boolean'),
      bigint: () => createMockSchema('any'),
      date: () => createMockSchema('any'),
    },
    NEVER: Symbol('NEVER'),
    infer: (schema) => schema,
    custom: () => createMockSchema('any'),
    ostring: () => createMockSchema('string', { required: false }),
    onumber: () => createMockSchema('number', { required: false }),
    oboolean: () => createMockSchema('boolean', { required: false }),
  },
};

module.exports = mockZod;
module.exports.z = mockZod.z;
module.exports.default = mockZod;